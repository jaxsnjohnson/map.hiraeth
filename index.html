<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive World Map Viewer</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>

    <!-- Google Font: EB Garamond -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap" rel="stylesheet">

    <style>
        /* --- Theme Variables --- */
        :root {
            /* Light Mode Backgrounds */
            --bg-primary: #fdfaf6; /* Lighter base */
            --bg-secondary: #f4f0eb; /* Slightly darker secondary */

            /* Light Mode Text */
            --text-primary: #6b2c25; /* User's Primary Color */
            --text-secondary: #bb9b73; /* User's Default Link Color */
            --popup-text: var(--text-primary); /* Match main text */

            /* Light Mode UI Elements */
            --border-color: #dcd3c8; /* Desaturated brown */
            --highlight-bg: rgba(212, 163, 106, 0.3); /* Based on Chapter Color w/ alpha */
            --active-bg: rgba(189, 137, 77, 0.5); /* Based on Page Color w/ alpha */
            --shadow-color: rgba(107, 44, 37, 0.15); /* Shadow based on primary */
            --slider-bg: #d4a36a; /* Chapter Color */
            --slider-color: white;
            --font-family-main: 'EB Garamond', serif;

            /* Light Mode Frosted Glass */
            --glass-bg-light: rgba(253, 250, 246, 0.75); /* Based on bg-primary w/ alpha */
            --glass-border-light: rgba(160, 82, 45, 0.3); /* Based on Shelf Color w/ alpha */
        }

        body.dark-theme {
            /* Dark Mode Backgrounds */
            --bg-primary: #222034; /* Darker version of user's primary */
            --bg-secondary: #1b1830; /* Even darker */

            /* Dark Mode Text */
            --text-primary: #e8e6f2; /* Light text for contrast */
            --text-secondary: #b9b8e0; /* User's Default Link Color */
            --popup-text: var(--text-primary);

            /* Dark Mode UI Elements */
            --border-color: #524f6c; /* User's Primary Color */
            --highlight-bg: rgba(237, 174, 73, 0.3); /* Based on Chapter Color w/ alpha */
            --active-bg: rgba(66, 159, 227, 0.4); /* Based on Page Color w/ alpha */
            --shadow-color: rgba(0, 0, 0, 0.3); /* Darker shadow */
            --slider-bg: #555;
            --slider-color: #429fe3; /* User's Page Color */
            /* font-family is inherited */

            /* Dark Mode Frosted Glass */
            --glass-bg-dark: rgba(34, 33, 50, 0.7); /* Based on user's primary w/ alpha */
            --glass-border-dark: rgba(245, 67, 91, 0.3); /* Based on Shelf Color w/ alpha */
        }

        /* --- Keyframes for WIP Popup Gradient Pulse --- */
        @keyframes pulseGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* --- Keyframes for Twinkling Stars --- */
        @keyframes twinkle {
            0% { opacity: 0; }
            50% { opacity: 0.6; } /* Adjust max brightness */
            100% { opacity: 0; }
        }

        /* --- Keyframes for Moving Clouds --- */
        @keyframes moveClouds {
            from { background-position-x: 0; }
            to { background-position-x: 1000px; } /* Adjust value based on image width & desired speed */
        }


        /* Apply Variables & Base Styles */
        html, body {
            height: 100%; margin: 0; padding: 0; font-family: var(--font-family-main);
            background-color: var(--bg-primary); color: var(--text-primary);
            overflow: hidden; transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container { display: flex; height: 100%; width: 100%; }

        /* Sidebar styling */
        #sidebar {
            background-color: var(--glass-bg-light); backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); border-right: 1px solid var(--glass-border-light);
            width: 250px; padding: 15px; box-shadow: 2px 0 15px var(--shadow-color);
            overflow-y: auto; flex-shrink: 0;
            transition: width 0.3s ease, padding 0.3s ease, background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            box-sizing: border-box; position: relative; display: flex; flex-direction: column;
        }
        body.dark-theme #sidebar { background-color: var(--glass-bg-dark); border-right-color: var(--glass-border-dark); }
        #sidebar h2 {
            margin-top: 0; margin-bottom: 15px; font-size: 1.5rem; font-weight: 600;
            border-bottom: 1px solid var(--glass-border-light); padding-bottom: 10px;
            white-space: nowrap; color: var(--text-primary); flex-shrink: 0;
        }
        body.dark-theme #sidebar h2 { border-bottom-color: var(--glass-border-dark); }

        /* Sidebar List Styling */
        #map-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #map-list li { border-radius: 4px; margin-bottom: 3px; overflow: hidden; }
        .map-item {
            padding: 10px 10px 10px 15px; cursor: pointer; transition: background-color 0.2s ease;
            white-space: nowrap; text-overflow: ellipsis; font-size: 1.1rem;
            background-color: transparent; display: block;
        }
        .map-item:hover { background-color: var(--highlight-bg); }
        .map-item.active { background-color: var(--active-bg); font-weight: 600; }
        .folder-header {
            padding: 10px 5px; cursor: pointer; font-weight: bold; display: flex;
            align-items: center; transition: background-color 0.2s ease; background-color: transparent;
            user-select: none; /* Prevent text selection on double click */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .folder-header:hover { background-color: var(--highlight-bg); }
        /* Style active folder header */
        .folder-header.active {
             background-color: var(--active-bg);
             font-weight: 600; /* Match map item active style */
        }
        .folder-toggle-icon { display: inline-block; width: 1.2em; text-align: center; margin-right: 5px; transition: transform 0.2s ease-in-out; }
        .folder.closed > .folder-header .folder-toggle-icon::before { content: '▸'; }
        .folder:not(.closed) > .folder-header .folder-toggle-icon::before { content: '▾'; }
        .nested-list { list-style: none; padding: 0; margin: 0 0 0 15px; max-height: 1000px; overflow: hidden; transition: max-height 0.3s ease-out; }
        .folder.closed > .nested-list { max-height: 0; }

        /* --- Coming Soon Sidebar Item Styling --- */
        .map-item.coming-soon {
            color: var(--text-secondary); /* Use secondary text color */
            font-style: italic;
            cursor: not-allowed; /* Indicate non-interactive */
            opacity: 0.7;
        }
        /* Optional: Prevent hover effect or use a different one */
        .map-item.coming-soon:hover {
            background-color: transparent; /* No highlight on hover */
        }
        /* Ensure dark theme also looks disabled */
        body.dark-theme .map-item.coming-soon {
             color: var(--text-secondary); /* Already uses variable */
        }
        body.dark-theme .map-item.coming-soon:hover {
             background-color: transparent;
        }

        /* Map container */
        #map-container { flex-grow: 1; height: 100%; position: relative; overflow: hidden; }
        #map {
            height: 100%; width: 100%;
            background-color: var(--bg-secondary);
            transition: background-color 0.3s ease;
            position: relative; /* Needed for pseudo-elements */
            overflow: hidden; /* Needed for pseudo-elements */
        }
        body.dark-theme #map {
            background-image: url('images/night-sky.png'); /* Base static stars */
            background-repeat: repeat;
            background-color: #050510;
        }

        /* --- Moving Clouds Effect (Light Mode Only) --- */
        /* Apply ONLY when dark-theme class is NOT present */
        body:not(.dark-theme) #map::before,
        body:not(.dark-theme) #map::after {
            /* --- IMPORTANT: Create or find a seamless tileable cloud image --- */
            /* --- Save it as images/clouds.png or update the path below --- */
            background-image: url('images/clouds.png');
            background-repeat: repeat-x; /* Repeat horizontally */
            background-size: auto 300px; /* Auto width, fixed height - adjust height as needed */
            /* background-size: cover; */ /* Alternative: stretches to cover, might distort clouds */
            width: 100%; /* Ensure it covers width */
            animation-name: moveClouds;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
            transition: opacity 0.5s ease-in-out; /* Smooth fade when changing themes */
            z-index: 0; /* Position behind map tiles but above map background */
            content: ''; /* Required for pseudo-elements */
            position: absolute; /* Position relative to #map */
            top: 0;
            left: 0;
            height: 100%; /* Cover height */
            pointer-events: none; /* Don't block map clicks */
        }

        /* Cloud Layer 1 (e.g., slightly faster, higher) */
        body:not(.dark-theme) #map::before {
            background-position: 0 5%; /* Start near top */
            opacity: 0.45; /* Adjust transparency */
            animation-duration: 75s; /* Adjust speed */
        }

        /* Cloud Layer 2 (e.g., slower, lower, more transparent) */
        body:not(.dark-theme) #map::after {
            background-position: 0 20%; /* Start lower down */
            opacity: 0.3; /* Adjust transparency */
            animation-duration: 110s; /* Adjust speed (make different from layer 1) */
            animation-delay: -10s; /* Offset start time slightly */
        }

        /* --- Ensure Dark Theme Hides Clouds --- */
        /* Explicitly hide cloud pseudo-elements in dark mode */
        /* And define star styles */
        body.dark-theme #map::before,
        body.dark-theme #map::after {
            opacity: 0; /* Hide clouds by default in dark mode */
            /* Star styles below will override specific properties */
        }

        /* --- Twinkling Star Effect (Dark Mode Only) --- */
        /* Star Layer 1 */
        body.dark-theme #map::before {
            /* Tiny white dot gradient, repeated */
            background-image: radial-gradient(circle, white 1px, transparent 1.5px); /* Override cloud image */
            /* Adjust size for star density */
            background-size: 75px 75px;
            background-position: 0 0;
            /* Apply animation */
            animation: twinkle 6s linear infinite; /* Slower twinkle */
            animation-delay: 0s;
            opacity: 1; /* Base opacity for stars (animation will vary it) */
        }

        /* Star Layer 2 (Slightly different density, offset, and speed) */
        body.dark-theme #map::after {
            background-image: radial-gradient(circle, white 1px, transparent 1.5px); /* Override cloud image */
            /* Denser stars */
            background-size: 55px 55px;
            /* Offset position */
            background-position: 25px 25px;
            /* Apply animation */
            animation: twinkle 4s linear infinite; /* Faster twinkle */
            animation-delay: 2s; /* Start later than the first layer */
            opacity: 1; /* Base opacity for stars (animation will vary it) */
        }
        /* --- End Theme Effects --- */


        /* Map Blurb */
        #map-blurb {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 999; /* Below controls but above map */
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            color: var(--popup-text); /* Use popup text color */
            border-radius: 6px;
            padding: 8px 12px;
            max-width: 250px; /* Limit width */
            font-size: 0.9rem;
            box-shadow: 0 1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, opacity 0.3s ease;
            opacity: 0; /* Hidden by default */
            pointer-events: none; /* Don't block map clicks */
        }
        #map-blurb.visible {
            opacity: 1;
        }
        body.dark-theme #map-blurb {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
        }

        /* Popups */
        .leaflet-popup-content-wrapper { background: var(--glass-bg-light); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); color: var(--popup-text); border-radius: 8px; box-shadow: 0 3px 14px var(--shadow-color); border: 1px solid var(--glass-border-light); }
        .leaflet-popup-tip { background: transparent; box-shadow: none; }
        body.dark-theme .leaflet-popup-content-wrapper { background: var(--glass-bg-dark); border-color: var(--glass-border-dark); }
        .leaflet-popup-content { margin: 15px; font-size: 1.1rem; line-height: 1.5; }
        .leaflet-popup-content h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.3rem; font-weight: 600; color: var(--popup-text); }
        .dark-theme .leaflet-popup-close-button { color: var(--text-secondary); }
        .dark-theme .leaflet-popup-close-button:hover { color: var(--text-primary); }

        /* --- Popup Link Styling --- */
        .leaflet-popup-content h3 a,
        .leaflet-popup-content h3 a:link,
        .leaflet-popup-content h3 a:visited {
            color: inherit; /* Inherit color from the h3 (uses --popup-text) */
            text-decoration: none; /* Remove default underline */
            border-bottom: 1px dotted; /* Subtle underline */
            transition: color 0.2s ease, border-bottom-color 0.2s ease;
        }
        .leaflet-popup-content h3 a:hover,
        .leaflet-popup-content h3 a:active {
            color: var(--text-secondary); /* Use secondary color on hover */
            border-bottom-style: solid; /* Make underline solid on hover */
        }
        /* Ensure dark theme hover looks okay */
        body.dark-theme .leaflet-popup-content h3 a:hover,
        body.dark-theme .leaflet-popup-content h3 a:active {
             color: var(--text-secondary); /* Already uses variable */
        }

        /* Buttons */
        #toggle-sidebar-btn { position: absolute; bottom: 43px; left: 15px; z-index: 1000; background-color: var(--glass-bg-light); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border: 1px solid var(--glass-border-light); color: var(--text-primary); border-radius: 4px; padding: 5px 8px; cursor: pointer; font-size: 1.2rem; line-height: 1; box-shadow: 0 1px 5px var(--shadow-color); transition: background-color 0.3s ease, border-color 0.3s ease; }
        #toggle-sidebar-btn:hover { background-color: rgba(255, 255, 255, 0.75); }
        body.dark-theme #toggle-sidebar-btn { background-color: var(--glass-bg-dark); border-color: var(--glass-border-dark); }
        body.dark-theme #toggle-sidebar-btn:hover { background-color: rgba(70, 70, 70, 0.75); }
        .container.sidebar-collapsed #sidebar { width: 0; padding-left: 0; padding-right: 0; overflow: hidden; border-right: none; }
        .leaflet-control-zoom a { background-color: var(--glass-bg-light); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border: 1px solid var(--glass-border-light); color: var(--text-primary); border-bottom: 1px solid var(--glass-border-light); transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease; }
        .leaflet-control-zoom-in { border-bottom: 1px solid var(--glass-border-light); border-radius: 4px 4px 0 0; }
        .leaflet-control-zoom-out { border-radius: 0 0 4px 4px; border: 1px solid var(--glass-border-light); border-top: none; }
        .leaflet-control-zoom a:hover { background-color: rgba(255, 255, 255, 0.75); color: #000; }
        body.dark-theme .leaflet-control-zoom a { background-color: var(--glass-bg-dark); border-color: var(--glass-border-dark); color: var(--text-primary); }
        body.dark-theme .leaflet-control-zoom-in { border-bottom: 1px solid var(--glass-border-dark); }
        body.dark-theme .leaflet-control-zoom-out { border: 1px solid var(--glass-border-dark); border-top: none; }
        body.dark-theme .leaflet-control-zoom a:hover { background-color: rgba(70, 70, 70, 0.75); color: #fff; }

        /* Marker Toggle Button */
        #toggle-markers-btn {
            position: absolute;
            top: 78px; /* Position below zoom controls */
            left: 12px;
            z-index: 1000;
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            color: var(--text-primary);
            border-radius: 4px;
            padding: 0; /* Remove padding for icon */
            width: 32px; /* Match zoom control width */
            height: 30px; /* Match zoom control height */
            cursor: pointer;
            font-size: 1.4rem; /* Adjust icon size */
            line-height: 30px; /* Center icon vertically */
            text-align: center;
            box-shadow: 0 1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
            /* Add icon content via pseudo-element */
            content: ''; /* Required for pseudo */
        }
        #toggle-markers-btn::before {
             /* Using a simple marker-like icon */
            content: '📍';
            opacity: 1; /* Default: visible */
            transition: opacity 0.2s ease;
        }
        #toggle-markers-btn.markers-hidden::before {
            opacity: 0.5; /* Dimmed when hidden */
        }

        #toggle-markers-btn:hover {
            background-color: rgba(255, 255, 255, 0.75);
        }
        body.dark-theme #toggle-markers-btn {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
            color: var(--text-primary);
        }
        body.dark-theme #toggle-markers-btn:hover {
            background-color: rgba(70, 70, 70, 0.75);
        }

        /* Theme Toggle */
        .theme-switch-wrapper { display: flex; align-items: center; margin-top: auto; padding-top: 15px; border-top: 1px solid var(--glass-border-light); flex-shrink: 0; white-space: nowrap; overflow: hidden; }
        body.dark-theme .theme-switch-wrapper { border-top-color: var(--glass-border-dark); }
        .theme-switch-wrapper span { margin-left: 10px; font-size: 1rem; color: var(--text-secondary); }
        .theme-switch { position: relative; display: inline-block; width: 50px; height: 24px; flex-shrink: 0; }
        .theme-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--slider-bg); transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: #2196F3; }
        input:checked + .slider:before { transform: translateX(26px); }
        .slider.round { border-radius: 24px; }
        .slider.round:before { border-radius: 50%; }

        /* Bottom Link Bar */
        #bottom-link-bar { position: absolute; bottom: 0; left: 0; width: 100%; height: 28px; background-color: var(--glass-bg-light); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-top: 1px solid var(--glass-border-light); box-sizing: border-box; display: flex; align-items: center; justify-content: center; padding: 0 15px; z-index: 1000; transition: background-color 0.3s ease, border-color 0.3s ease; }
        #bottom-link-bar a { color: var(--text-secondary); text-decoration: none; font-size: 0.85rem; margin: 0 8px; transition: color 0.2s ease; }
        #bottom-link-bar a:hover { color: var(--text-primary); text-decoration: underline; }
        body.dark-theme #bottom-link-bar { background-color: var(--glass-bg-dark); border-top-color: var(--glass-border-dark); }
        body.dark-theme #bottom-link-bar a { color: var(--text-secondary); }
        body.dark-theme #bottom-link-bar a:hover { color: var(--text-primary); }

        /* WIP Popup */
        #wip-popup { position: fixed; bottom: 43px; right: 15px; z-index: 1001; padding: 8px 12px; border: 1px solid var(--glass-border-light); border-radius: 6px; box-shadow: 0 2px 6px var(--shadow-color); transition: border-color 0.3s ease, color 0.3s ease; background: linear-gradient(to right, #ff7e7e, #ffae70, #fff078, #ffae70, #ff7e7e); background-size: 300% 100%; animation: pulseGradient 30s ease-in-out infinite; }
        #wip-popup p { margin: 0; font-size: 0.8rem; color: var(--text-primary); text-align: center; white-space: nowrap; text-shadow: 0px 0px 3px rgba(0, 0, 0, 0.4); }
        body.dark-theme #wip-popup { border-color: var(--glass-border-dark); }
        body.dark-theme #wip-popup p { text-shadow: 0px 0px 3px rgba(0, 0, 0, 0.6); }

    </style>
</head>
<body>
    <!-- Container and Map Structure -->
    <div class="container">
        <div id="sidebar">
            <h2>Select Map</h2>
            <ul id="map-list">
                <!-- Populated by JS -->
            </ul>
            <div class="theme-switch-wrapper">
                <label class="theme-switch" for="theme-checkbox">
                    <input type="checkbox" id="theme-checkbox" />
                    <div class="slider round"></div>
                </label>
                <span>Dark Mode</span>
            </div>
        </div>
        <div id="map-container">
            <button id="toggle-sidebar-btn" title="Collapse Sidebar">&laquo;</button>
            <div id="map"></div>

            <!-- Map Blurb Display -->
            <div id="map-blurb"></div>

            <!-- Marker Toggle Button -->
            <button id="toggle-markers-btn" title="Toggle Markers" class="leaflet-control"></button>

            <!-- Bottom Link Bar -->
            <div id="bottom-link-bar">
                <a href="https://jsnj.link/maps-to-wiki" target="_blank">Wiki</a> |
                <a href="https://jsnj.link/maps-blog-post" target="_blank">Blog</a> |
                <a href="about.html" target="_blank">About </a> |
                <a href="https://jsnj.link/map-hiraeth-source" target="_blank">Source </a>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>

    <!-- Main Application JS -->
    <script>
        // --- Map Data Configuration ---
        const mapData = [
            {
                type: 'folder', // It's a folder...
                id: 'main_continent', // ...but it also represents/links to this map ID
                name: 'Content Map', // Display name for the folder/link
                // Include map details for the folder's own map here
                width: 1680,
                height: 1120,
                imageUrl: 'maps/cos-map.jpg',
                blurb: "The main continent, featuring diverse regions from frozen peaks to bustling capitals.",
                pointsOfInterest: [ // Points relevant to the main world map
                     // Example with wikiLink
                     { coords: [1120 * 0.75, 1680 * 0.5], name: "Capital City", description: "The bustling heart of the kingdom.", wikiLink: "https://your-wiki.com/Capital_City" },
                     { coords: [1120 * 0.3, 1680 * 0.2], name: "Ancient Ruins", description: "Mysterious remnants of a bygone era." }, // No link
                     { coords: [1120 * 0.5, 1680 * 0.8], name: "Whispering Woods", description: "An old forest where secrets linger.", wikiLink: "https://your-wiki.com/Whispering_Woods" },
                     { coords: [1120 * 0.8, 1680 * 0.3], name: "Frozen Peak", description: "The highest, coldest mountain.", wikiLink: "https://your-wiki.com/Frozen_Peak" },
                     { coords: [1120 * 0.4, 1680 * 0.7], name: "Coastal Village", description: "A small fishing settlement." },
                     { coords: [1120 * 0.2, 1680 * 0.15], name: "Icebeach Region", description: "Link to the detailed map.", wikiLink: "https://your-wiki.com/Icebeach" } // Link to general region
                ],
                // Children maps nested within this folder
                children: [
                    {
                        id: 'icebeach_detail', // ID for the detail map
                        name: 'Icebeach', // Display name for the sub-link
                        width: 7016,
                        height: 4960,
                        imageUrl: 'maps/IceBeach.png',
                        blurb: "A detailed view of the Icebeach region, known for its harsh climate and resilient settlements.",
                        pointsOfInterest: [
                            // Add wikiLink properties here as needed
                            { coords: [3516, 3698], name: "Castgate", description: "Renowned for its picturesque beauty and protective magical dome, this town thrives on fishing, shipbuilding, and gemstone mining, serving as a hub influenced by the Athenaeum and marked by historical battles.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/casgate" },
                            { coords: [4002, 3488], name: "Winrich Fortress", description: "The Ancient fortress of a long dead and powerful Lich", wikiLink: "https://your-wiki.com/Winrich_Fortress" },
                            { coords: [4266, 3192], name: "Whitedrift", description: "Located at the mouth of the Curse Run near the Winrich glacier, this small town houses an unstable population tasked with monitoring the glacier, including some former asylum inmates.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/whitedrift" }, // No link example
                            { coords: [3876, 2990], name: "Icemoor", description: "Once tasked with watching the Winrich Glacier from its tall tower, this settlement is now mostly abandoned, left with only a few older men maintaining the vigil after the endless winter.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/icemoor" },
                            { coords: [4358, 2976], name: "Little Rock Mentle Asylam", description: "This small institution holds some of the most hardened crimnals of the Gilded Nations.", wikiLink: "https://your-wiki.com/Little_Rock_Asylum" },
                            { coords: [1664, 3372], name: "Ottiker", description: "Founded by immigrants on the shores of Sleetmond Lake, this town is recognized for its winery, despite recent conflicts with local druids halting deliveries.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/niror" },
                            { coords: [2310, 2722], name: "Fractured Point", description: "Perched on a rocky crag, this walled town often serves as the first stop for visitors, acting as a lighthouse and beacon where traders find ways to prosper despite the harsh conditions.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/the-fractured-point" },
                            { coords: [2036, 3074], name: "The Hope Tree", description: "A tall tree provides shelter and wamth in the surrounding area.  It is said the tree is super magical and its leaves can make a healing tea.", wikiLink: "https://your-wiki.com/Hope_Tree" },
                            { coords: [1210, 3924], name: "Quilt", description: "Situated on the Foaming Loch, this small community practices fish farming and is named for the distinctive dyed quilts crafted from local Icesheep wool.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/quilt" },
                            { coords: [2154, 3588], name: "Sleetmond", description: "Home to druidic practices centered around The Hope Tree and a Sugar Maple orchard, this small lakeside town supplements its diet with fish and unique Icebeach sheep, though its ways are sometimes distrusted.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/sleetmond" },
                            { coords: [1116, 4038], name: "The Foaming Burrow", description: "The origin of the river, how water bubbles forth outo of this cave." },
                            { coords: [2862, 4840], name: "Thrawbreak", description: "Nestled below the Auruan mountains, this quiet, isolated town originated as a mountaineering camp and is now known for its resilient tavern culture amidst surrounding ruins.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/thrawbreak" },
                            { coords: [3422, 4370], name: "Gernerum", description: "Now destroyed after a battle with a mechanical dragon, this former town was once home to several notable figures from Icebeach history, with only a hag rumored to have survived.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/gernerum" },
                            { coords: [2938, 4182], name: "Morana's Fang", description: "The tallest point in the world.", wikiLink: "https://your-wiki.com/Moranas_Fang" },
                            { coords: [1356, 1620], name: "Shiverwallow", description: "Protected by a wooden wall extending into the now-frozen harbor, this town boasts the largest fishing fleet, adapting its industry to ice fishing during the eternal winter.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/shiverwallow" },
                            { coords: [604, 2416], name: "Mt. Solaria", description: "A large mountian said to be inhabited by a dragon.", wikiLink: "https://your-wiki.com/Mt_Solaria" },
                            { coords: [780, 1080], name: "Houlen Top", description: "Known as the \"breadbasket of the north,\" this southernmost town cultivates grains and root vegetables in its valley, though its inhabitants are notably guarded against outsiders.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/howlentop" },
                            { coords: [716, 1508], name: "Wynwood Peak", description: "This smaller mountian is said to be a place were the...", wikiLink: "https://your-wiki.com/Wynwood_Peak" }
                        ]
                    },
                    // --- Example "Coming Soon" Item ---
                    {
                        id: 'Old-Lin', // Still needs an ID for potential future use
                        name: 'Old-Lin',
                        status: 'coming-soon' // Mark as coming soon
                        // No width, height, imageUrl, blurb, or pointsOfInterest needed yet
                    },
                    {
                        id: 'southern-thalassia', // Still needs an ID for potential future use
                        name: 'Southern Thalassia',
                        status: 'coming-soon' // Mark as coming soon
                        // No width, height, imageUrl, blurb, or pointsOfInterest needed yet
                    }
                ]
            },
            // --- Example Top-Level "Coming Soon" Item ---
            {
                 id: 'system',
                 name: 'Solar System',
                 status: 'coming-soon'
            }
            // Add other top-level folders or maps here
        ];

        // --- Initialize Leaflet Map ---
        const map = L.map('map', {
            crs: L.CRS.Simple,
            minZoom: -2,
            maxZoom: 3,
            attributionControl: false,
        });

        // --- Global variables ---
        let currentImageLayer = null;
        let currentMarkerGroup = null; // To manage markers as a layer
        let currentBounds = null;
        let currentlyLoadedMapId = null;
        let currentSidebarState = 'o';
        let markersVisible = true; // Track marker visibility state

        // --- DOM Elements ---
        const container = document.querySelector('.container');
        const sidebar = document.getElementById('sidebar');
        const mapListElement = document.getElementById('map-list');
        const toggleBtn = document.getElementById('toggle-sidebar-btn');
        const themeToggle = document.getElementById('theme-checkbox');
        const bodyElement = document.body;
        const mapBlurbElement = document.getElementById('map-blurb'); // Get blurb element
        const toggleMarkersBtn = document.getElementById('toggle-markers-btn'); // Get marker toggle button
        const transitionDuration = 300;

        // --- Helper Functions ---
        function parseHash() {
            const hash = window.location.hash.substring(1);
            let mapId = null;
            let sidebarState = null;
            if (hash) {
                const parts = hash.split('-s=');
                mapId = parts[0];
                if (parts.length > 1 && ['o', 'c'].includes(parts[1])) {
                    sidebarState = parts[1];
                }
            }
             // Find the default map ID more robustly for initialization
            let defaultMapId = null;
            function findFirstId(items) {
                for (const item of items) {
                    // Skip coming soon items when looking for the first *loadable* map
                    if (item.id && item.status !== 'coming-soon') return item.id;
                    if (item.type === 'folder' && item.children) {
                        const foundId = findFirstId(item.children);
                        if (foundId) return foundId; // Found loadable ID in children
                    }
                }
                // Fallback: If *only* coming-soon items exist, return the first ID found anyway
                for (const item of items) {
                     if (item.id) return item.id;
                     if (item.type === 'folder' && item.children) {
                         const foundId = findFirstId(item.children); // Re-run without status check
                         if (foundId) return foundId;
                     }
                }
                return null;
            }
            defaultMapId = findFirstId(mapData);

            return {
                mapId: mapId || defaultMapId, // Use hash ID if present, else default
                sidebarState: sidebarState || 'o'
            };
        }
        function generateHash(mapId, sidebarState) {
            return `#${mapId}-s=${sidebarState}`;
        }

        // --- Function to Set Sidebar State ---
        function setSidebarState(state, updateHash = true) {
            const shouldBeCollapsed = (state === 'c');
            const isCurrentlyCollapsed = container.classList.contains('sidebar-collapsed');
            if (shouldBeCollapsed !== isCurrentlyCollapsed) {
                console.log(`Setting sidebar state to: ${state}`);
                container.classList.toggle('sidebar-collapsed', shouldBeCollapsed);
                if (shouldBeCollapsed) {
                    toggleBtn.innerHTML = '&raquo;'; toggleBtn.title = 'Expand Sidebar';
                } else {
                    toggleBtn.innerHTML = '&laquo;'; toggleBtn.title = 'Collapse Sidebar';
                }

                setTimeout(() => { map.invalidateSize({ animate: true }); }, transitionDuration);
                 currentSidebarState = state;
                 if (updateHash && currentlyLoadedMapId) {
                     const newHash = generateHash(currentlyLoadedMapId, state);
                     console.log("Updating hash from setSidebarState:", newHash);
                     history.replaceState(null, '', newHash);
                 }
            } else {
                 currentSidebarState = state;
                 console.log(`Sidebar already in state: ${state}`);
            }
        }

        // --- Function to Load/Switch Map ---
        function loadMap(mapId, updateHash = true) {
            // Find the map data recursively
            let selectedMap = null;
            function findMap(items, id) {
                for (const item of items) {
                    if (item.id === id) { return item; } // Check item itself
                    if (item.type === 'folder' && item.children) { // Search children
                        const found = findMap(item.children, id);
                        if (found) return found;
                    }
                }
                return null;
            }
            selectedMap = findMap(mapData, mapId);

            // --- Check if map is coming soon BEFORE trying to load ---
            if (!selectedMap || selectedMap.status === 'coming-soon') {
                console.warn("Attempted to load map data not found or coming soon:", mapId);
                if (selectedMap) { // Only alert if found but coming soon
                     alert(`The map "${selectedMap.name}" is coming soon!`);
                }
                // Potentially clear the map or show a placeholder? For now, just return.
                return;
            }

            // Prevent reload only if map ID AND the actual map data object are the same
            if (mapId === currentlyLoadedMapId && selectedMap.type !== 'folder') {
                 console.log(`Map ${mapId} is already loaded.`);
                 if (updateHash) {
                     const currentHash = generateHash(mapId, currentSidebarState);
                     if (window.location.hash !== currentHash) {
                          console.log("Updating hash from loadMap (state change only):", currentHash);
                          history.replaceState(null, '', currentHash);
                     }
                 }
                 return;
            }

            console.log(`Loading map: ${selectedMap.name} (ID: ${mapId})`);

            // --- Map Loading Logic ---
            // Remove previous layers
            if (currentImageLayer) map.removeLayer(currentImageLayer);
            if (currentMarkerGroup) map.removeLayer(currentMarkerGroup); // Remove marker group

            // Create new marker group for this map
            currentMarkerGroup = L.layerGroup();

            const mapHeight = selectedMap.height;
            const mapWidth = selectedMap.width;
            if (isNaN(mapHeight) || isNaN(mapWidth)) {
                console.error(`Invalid dimensions for map ID ${mapId}: H=${mapHeight}, W=${mapWidth}`);
                return;
            }
            currentBounds = [[0, 0], [mapHeight, mapWidth]];
            currentImageLayer = L.imageOverlay(selectedMap.imageUrl, currentBounds).addTo(map);

            // Add Points of Interest to the Marker Group
            (selectedMap.pointsOfInterest || []).forEach(point => {
                if (point.coords && point.coords.length === 2 && !isNaN(point.coords[0]) && !isNaN(point.coords[1])) {
                    if (point.coords[0] >= 0 && point.coords[0] <= mapHeight && point.coords[1] >= 0 && point.coords[1] <= mapWidth) {
                         const marker = L.marker(point.coords); // Create marker

                         // --- Create Popup Content with Conditional Link ---
                         let popupContent = '';
                         if (point.wikiLink) {
                             // Use rel="noopener noreferrer" for security with target="_blank"
                             popupContent += `<h3><a href="${point.wikiLink}" target="_blank" rel="noopener noreferrer" title="Visit wiki page for ${point.name}">${point.name}</a></h3>`;
                         } else {
                             popupContent += `<h3>${point.name}</h3>`;
                         }
                         popupContent += `<p>${point.description || ''}</p>`;
                         // --- End Popup Content Creation ---

                         marker.bindPopup(popupContent); // Bind the generated content
                         marker.addTo(currentMarkerGroup); // Add to the group
                    } else { console.warn(`POI coordinates out of bounds for map ${selectedMap.name}: ${point.name}`, point.coords); }
                } else { console.warn(`Invalid coordinates for POI: ${point.name}`, point.coords); }
            });


            // Add marker group to map *if* markers should be visible
            if (markersVisible) {
                currentMarkerGroup.addTo(map);
            }
            // Update marker toggle button state visually
            toggleMarkersBtn.classList.toggle('markers-hidden', !markersVisible);


            map.fitBounds(currentBounds);

            // Update Map Blurb
            if (selectedMap.blurb) {
                mapBlurbElement.textContent = selectedMap.blurb;
                mapBlurbElement.classList.add('visible');
            } else {
                mapBlurbElement.textContent = '';
                mapBlurbElement.classList.remove('visible');
            }
            // --- End Map Loading Logic ---

            // --- Update Sidebar Active State ---
            document.querySelectorAll('#map-list .map-item, #map-list .folder-header').forEach(item => item.classList.remove('active'));
            const activeMapItem = document.querySelector(`#map-list .map-item[data-map-id="${mapId}"]`);
            const activeFolderHeader = document.querySelector(`#map-list .folder-header[data-map-id="${mapId}"]`);
            if (activeMapItem) {
                activeMapItem.classList.add('active');
                let parent = activeMapItem.closest('.nested-list');
                while (parent) {
                    const folderLi = parent.closest('.folder');
                    if (folderLi && folderLi.classList.contains('closed')) { folderLi.classList.remove('closed'); }
                    parent = folderLi?.parentElement.closest('.nested-list');
                }
            } else if (activeFolderHeader) {
                activeFolderHeader.classList.add('active');
                 const folderLi = activeFolderHeader.closest('.folder');
                 if (folderLi && folderLi.classList.contains('closed')) { folderLi.classList.remove('closed'); }
            }
            // --- End Active State Update ---

            currentlyLoadedMapId = mapId;
            if (updateHash) {
                const newHash = generateHash(mapId, currentSidebarState);
                console.log("Updating hash from loadMap:", newHash);
                history.pushState({ mapId: mapId, sidebarState: currentSidebarState }, selectedMap.name, newHash);
            }
            console.log(`Finished loading map: ${selectedMap.name}`);
        }

        // --- Populate Sidebar (Recursive Function) ---
        function populateSidebar(parentElement, items) {
            items.forEach(item => {
                const listItem = document.createElement('li');

                if (item.type === 'folder') {
                    // --- Folder Logic ---
                    listItem.classList.add('folder', 'closed');

                    const header = document.createElement('div');
                    header.classList.add('folder-header');
                    header.innerHTML = `<span class="folder-toggle-icon"></span><span>${item.name}</span>`;

                    const nestedList = document.createElement('ul');
                    nestedList.classList.add('nested-list');
                    if (item.children && item.children.length > 0) {
                        populateSidebar(nestedList, item.children);
                    }

                    // Single click: Toggle visibility
                    header.addEventListener('click', (e) => {
                        e.stopPropagation();
                        listItem.classList.toggle('closed');
                        console.log(`Folder '${item.name}' toggled.`);
                    });

                    // Double click: Load map IF the folder has an associated map ID AND is not 'coming-soon'
                    if (item.id) {
                        header.dataset.mapId = item.id; // Keep for active state styling
                        if (item.status === 'coming-soon') {
                            header.title = `${item.name} - Coming Soon!`;
                            header.classList.add('coming-soon'); // Add class for potential styling
                            header.addEventListener('dblclick', (e) => {
                                e.stopPropagation();
                                alert(`The map "${item.name}" is coming soon!`);
                            });
                        } else {
                            header.title = `Click to toggle '${item.name}', double-click to load map.`;
                            header.addEventListener('dblclick', (e) => {
                                e.stopPropagation();
                                console.log(`Folder header double-clicked, loading map: ${item.id}`);
                                loadMap(item.id, true); // Load THIS folder's map
                            });
                        }
                    } else {
                         // Title for folders that only toggle (no associated map)
                         header.title = `Click to toggle '${item.name}'.`;
                    }

                    listItem.appendChild(header);
                    listItem.appendChild(nestedList);

                } else if (item.status === 'coming-soon') {
                    // --- Handle "Coming Soon" Map Items ---
                    listItem.classList.add('map-item', 'coming-soon');
                    listItem.textContent = `${item.name} (Soon)`; // Indicate status
                    listItem.title = `${item.name} - Coming Soon!`; // Tooltip
                    listItem.dataset.mapId = item.id; // Keep ID for potential future use

                    // Add a click listener for an alert
                    listItem.addEventListener('click', (e) => {
                        e.stopPropagation();
                        alert(`The map "${item.name}" is coming soon!`);
                    });

                } else {
                    // --- Handle Regular Map Items ---
                    listItem.classList.add('map-item');
                    listItem.textContent = item.name;
                    listItem.dataset.mapId = item.id;
                    listItem.title = `Load map: ${item.name}`; // Tooltip

                    // Single click loads the map
                    listItem.addEventListener('click', (e) => {
                         e.stopPropagation();
                        loadMap(item.id, true);
                    });
                }
                parentElement.appendChild(listItem);
            });
        }
        populateSidebar(mapListElement, mapData); // Initial population call

        // --- Sidebar Toggle Button Logic ---
        toggleBtn.addEventListener('click', () => {
            const newState = container.classList.contains('sidebar-collapsed') ? 'o' : 'c';
            setSidebarState(newState, true);
        });

        // --- Theme Toggle Logic ---
        function applyTheme(theme) {
            if (theme === 'dark') { bodyElement.classList.add('dark-theme'); themeToggle.checked = true; }
            else { bodyElement.classList.remove('dark-theme'); themeToggle.checked = false; }
        }
        themeToggle.addEventListener('change', () => {
            const newTheme = themeToggle.checked ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme); applyTheme(newTheme);
        });
        const savedTheme = localStorage.getItem('theme') || 'light';
        applyTheme(savedTheme);

        // --- Helper: Log Coordinates on Click ---
        map.on('click', function(e) {
            if (currentBounds) { console.log(`Map clicked at: [${Math.round(e.latlng.lat)}, ${Math.round(e.latlng.lng)}] (Y, X from bottom-left)`); }
        });

        // --- Handle Hash Changes ---
        window.addEventListener('hashchange', () => {
            console.log("Hash changed event. New hash:", window.location.hash);
            const { mapId: mapIdFromHash, sidebarState: stateFromHash } = parseHash();

            // Find the map data to check its status
            let mapDataFromHash = null;
            function findMap(items, id) {
                for (const item of items) {
                    if (item.id === id) { return item; }
                    if (item.type === 'folder' && item.children) {
                        const found = findMap(item.children, id);
                        if (found) return found;
                    }
                } return null;
            }
            mapDataFromHash = findMap(mapData, mapIdFromHash);

            // Check if map needs changing AND isn't coming soon
            if (mapIdFromHash && mapIdFromHash !== currentlyLoadedMapId && mapDataFromHash?.status !== 'coming-soon') {
                console.log("Hashchange: Loading map", mapIdFromHash);
                loadMap(mapIdFromHash, false);
            } else if (mapDataFromHash?.status === 'coming-soon') {
                 console.log("Hashchange: Map is coming soon, not loading.", mapIdFromHash);
                 // Optionally show alert or update UI to reflect 'coming soon' state
            }
            // Check if sidebar needs changing
            if (stateFromHash && stateFromHash !== currentSidebarState) {
                 console.log("Hashchange: Setting sidebar state", stateFromHash);
                 setSidebarState(stateFromHash, false);
            }
        });

        // --- Marker Toggle Button Logic ---
        toggleMarkersBtn.addEventListener('click', () => {
            markersVisible = !markersVisible; // Toggle state
            if (currentMarkerGroup) { // Ensure group exists
                if (markersVisible) {
                    map.addLayer(currentMarkerGroup);
                    toggleMarkersBtn.title = "Hide Markers";
                } else {
                    map.removeLayer(currentMarkerGroup);
                    toggleMarkersBtn.title = "Show Markers";
                }
                toggleMarkersBtn.classList.toggle('markers-hidden', !markersVisible);
            }
            console.log(`Markers toggled. Visible: ${markersVisible}`);
        });

        // --- Initial Page Load Logic ---
        function initializeApp() {
             // Find the default map ID (first *loadable* ID encountered)
            let defaultMapId = null;
            function findFirstLoadableId(items) {
                for (const item of items) {
                    if (item.id && item.status !== 'coming-soon') return item.id;
                    if (item.type === 'folder' && item.children) {
                        const foundId = findFirstLoadableId(item.children);
                        if (foundId) return foundId;
                    }
                }
                 // Fallback: If only coming-soon items exist, return the first ID found
                 for (const item of items) {
                     if (item.id) return item.id;
                     if (item.type === 'folder' && item.children) {
                         const foundId = findFirstLoadableId(item.children); // Re-run without status check
                         if (foundId) return foundId;
                     }
                 }
                return null;
            }
            defaultMapId = findFirstLoadableId(mapData);

            const { mapId: hashId, sidebarState: initialSidebarState } = parseHash();

            // Need findMap helper available here too
            function findMap(items, id) {
                for (const item of items) {
                    if (item.id === id) { return item; }
                    if (item.type === 'folder' && item.children) {
                        const found = findMap(item.children, id);
                        if (found) return found;
                    }
                }
                return null;
            }

            let mapToLoadData = null;
            let mapIdToLoad = null;

            // Prioritize hash ID if it exists and is valid (not coming soon)
            if (hashId) {
                const potentialMap = findMap(mapData, hashId);
                if (potentialMap && potentialMap.status !== 'coming-soon') {
                    mapToLoadData = potentialMap;
                    mapIdToLoad = hashId;
                } else {
                     console.log("Hash ID points to invalid or coming-soon map, falling back to default.");
                }
            }

            // If hash didn't provide a loadable map, use the default
            if (!mapIdToLoad && defaultMapId) {
                 mapToLoadData = findMap(mapData, defaultMapId);
                 // Check if the default itself is coming soon (edge case)
                 if (mapToLoadData && mapToLoadData.status !== 'coming-soon') {
                     mapIdToLoad = defaultMapId;
                 } else {
                      console.log("Default map ID is coming soon or invalid.");
                      mapToLoadData = null; // Ensure we don't try to load it
                 }
            }


            console.log("Initializing App. Map to Load:", mapIdToLoad, "Initial Sidebar State:", initialSidebarState);

            setSidebarState(initialSidebarState, false); // Set sidebar first

            if (mapIdToLoad && mapToLoadData) {
                // Initialize marker visibility state BEFORE loading the first map
                markersVisible = true; // Default to visible
                toggleMarkersBtn.classList.remove('markers-hidden');
                toggleMarkersBtn.title = "Hide Markers";
                toggleMarkersBtn.style.display = ''; // Ensure button is visible

                loadMap(mapIdToLoad, false); // Load map
            } else {
                console.error("No loadable map data configured or default map ID found.");
                sidebar.innerHTML = '<h2>Select Map</h2><p>No maps available.</p>';
                // Hide blurb and toggle button if no map loads
                mapBlurbElement.classList.remove('visible');
                toggleMarkersBtn.style.display = 'none';
                // Ensure URL doesn't point to a non-existent/coming-soon map
                history.replaceState(null, '', generateHash('', initialSidebarState)); // Clear map part of hash
                return;
            }

            // Ensure URL reflects actual initial state (only if a map was loaded)
            if (currentlyLoadedMapId) {
                const correctInitialHash = generateHash(currentlyLoadedMapId, currentSidebarState);
                console.log("Replacing initial history state with:", correctInitialHash);
                history.replaceState({ mapId: currentlyLoadedMapId, sidebarState: currentSidebarState }, '', correctInitialHash);
            } else {
                 // If we ended up here without loading a map (e.g., only coming soon exist)
                 history.replaceState(null, '', generateHash('', currentSidebarState));
            }
        }

        initializeApp(); // Run initialization

    </script>

    <!-- Work in Progress Popup -->
    <div id="wip-popup">
        <p>This is a Work in Progress</p>
        <p>Markers & Names Not Acurate</p>
    </div>

</body>
</html>